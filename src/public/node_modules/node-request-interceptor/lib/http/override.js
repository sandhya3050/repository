"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var https_1 = __importDefault(require("https"));
var http_1 = __importDefault(require("http"));
var ClientRequestOverride_1 = require("./ClientRequest/ClientRequestOverride");
var debug = require('debug')('http override');
// Store a pointer to the original `http.ClientRequest` class
// so it can be mutated during runtime, affecting any subsequent calls.
var originalClientRequest;
function handleRequest(protocol, originalMethod, middleware, args) {
    var _a;
    if (!originalClientRequest) {
        var ClientRequestOverride = ClientRequestOverride_1.createClientRequestOverrideClass(middleware, originalMethod, originalClientRequest);
        debug('patching native http.ClientRequest...');
        // @ts-ignore
        http_1.default.ClientRequest = ClientRequestOverride;
    }
    debug('new http.ClientRequest (origin: %s)', protocol);
    // @ts-ignore
    return new ((_a = http_1.default.ClientRequest).bind.apply(_a, __spreadArrays([void 0], args)))();
}
/**
 * Overrides native `http` and `https` request issuing functions
 * using a given request interception middleware.
 */
exports.overrideHttpModule = function (middleware) {
    var patchedModules = {};
    var modules = ['http', 'https'];
    modules.forEach(function (protocol) {
        var module = protocol === 'https' ? https_1.default : http_1.default;
        var originalRequest = module.request, originalGet = module.get;
        // Wrap an original `http.request`/`https.request`
        // so that its invocations can be debugged.
        function proxiedOriginalRequest() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            debug('%s.request original call', protocol);
            // @ts-ignore
            return originalRequest.apply(void 0, args);
        }
        debug('patching "%s" module...', protocol);
        // @ts-ignore
        module.request = function requestOverride() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            debug('%s.request proxy call', protocol);
            return handleRequest(protocol, proxiedOriginalRequest.bind(module), middleware, args);
        };
        // @ts-ignore
        module.get = function getOverride() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            debug('%s.get call', protocol);
            var req = handleRequest(protocol, originalGet.bind(module), middleware, args);
            req.end();
            return req;
        };
        patchedModules[protocol] = {
            module: module,
            request: originalRequest,
            get: originalGet,
        };
    });
    return function () {
        debug('restoring patches...');
        Object.values(patchedModules).forEach(function (_a) {
            var module = _a.module, request = _a.request, get = _a.get;
            module.request = request;
            module.get = get;
        });
        patchedModules = {};
    };
};
