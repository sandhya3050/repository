'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var nodeRequestInterceptor = require('node-request-interceptor');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

var parse_1 = parse;

/**
 * Module variables.
 * @private
 */

var decode = decodeURIComponent;
var pairSplitRegExp = /; */;

/**
 * Parse a cookie header.
 *
 * Parse the given cookie header string into an object
 * The object has the various cookies as keys(names) => values
 *
 * @param {string} str
 * @param {object} [options]
 * @return {object}
 * @public
 */

function parse(str, options) {
  if (typeof str !== 'string') {
    throw new TypeError('argument str must be a string');
  }

  var obj = {};
  var opt = options || {};
  var pairs = str.split(pairSplitRegExp);
  var dec = opt.decode || decode;

  for (var i = 0; i < pairs.length; i++) {
    var pair = pairs[i];
    var eq_idx = pair.indexOf('=');

    // skip things that don't look like key=value
    if (eq_idx < 0) {
      continue;
    }

    var key = pair.substr(0, eq_idx).trim();
    var val = pair.substr(++eq_idx, pair.length).trim();

    // quoted values
    if ('"' == val[0]) {
      val = val.slice(1, -1);
    }

    // only assign once
    if (undefined == obj[key]) {
      obj[key] = tryDecode(val, dec);
    }
  }

  return obj;
}

/**
 * Try decoding a string using a decoding function.
 *
 * @param {string} str
 * @param {function} decode
 * @private
 */

function tryDecode(str, decode) {
  try {
    return decode(str);
  } catch (e) {
    return str;
  }
}

function createCommonjsModule(fn, basedir, module) {
	return module = {
	  path: basedir,
	  exports: {},
	  require: function (path, base) {
      return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
    }
	}, fn(module, module.exports), module.exports;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

var Headers_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
var HEADERS_INVALID_CHARACTERS = /[^a-z0-9\-#$%&'*+.^_`|~]/i;
var Headers = /** @class */ (function () {
    function Headers(headers) {
        var _this = this;
        this.map = {};
        if ((headers === null || headers === void 0 ? void 0 : headers.constructor.name) === 'Headers') {
            headers.forEach(function (value, name) {
                _this.append(name, value);
            }, this);
        }
        else if (Array.isArray(headers)) {
            headers.forEach(function (_a) {
                var name = _a[0], value = _a[1];
                _this.append(name, Array.isArray(value) ? value.join(', ') : value);
            });
        }
        else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function (name) {
                _this.append(name, headers[name]);
            });
        }
    }
    /**
     * Sets a new value for an existing header inside a `Headers` object, or adds the header if it does not already exist.
     */
    Headers.prototype.set = function (name, value) {
        this.map[this.normalizeName(name)] = this.normalizeValue(value);
    };
    /**
     * Appends a new value onto an existing header inside a `Headers` object, or adds the header if it does not already exist.
     */
    Headers.prototype.append = function (name, value) {
        name = this.normalizeName(name);
        value = this.normalizeValue(value);
        this.map[name] = this.has(name) ? this.map[name] + ", " + value : value;
    };
    /**
     * Deletes a header from the `Headers` object.
     */
    Headers.prototype.delete = function (name) {
        delete this.map[this.normalizeName(name)];
        return this;
    };
    /**
     * Returns a `ByteString` sequence of all the values of a header with a given name.
     */
    Headers.prototype.get = function (name) {
        return this.map[this.normalizeName(name)] || null;
    };
    /**
     * Returns the map of all headers in a `Headers` object.
     */
    Headers.prototype.getAllHeaders = function () {
        return this.map;
    };
    /**
     * Returns a boolean stating whether a `Headers` object contains a certain header.
     */
    Headers.prototype.has = function (name) {
        return this.map.hasOwnProperty(this.normalizeName(name));
    };
    Headers.prototype.forEach = function (callback, thisArg) {
        for (var name_1 in this.map) {
            if (this.map.hasOwnProperty(name_1)) {
                callback.call(thisArg, this.map[name_1], name_1, this);
            }
        }
    };
    Headers.prototype.normalizeName = function (name) {
        if (typeof name !== 'string') {
            name = String(name);
        }
        if (HEADERS_INVALID_CHARACTERS.test(name) || name.trim() === '') {
            throw new TypeError('Invalid character in header field name');
        }
        return name.toLowerCase();
    };
    Headers.prototype.normalizeValue = function (value) {
        if (typeof value !== 'string') {
            value = String(value);
        }
        return value;
    };
    return Headers;
}());
exports.Headers = Headers;
});

var headersToList_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
function headersToList(headers) {
    var headersList = [];
    headers.forEach(function (value, name) {
        var resolvedValue = value.includes(',')
            ? value.split(',').map(function (v) { return v.trim(); })
            : value;
        headersList.push([name, resolvedValue]);
    });
    return headersList;
}
exports.headersToList = headersToList;
});

var headersToObject_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
// List of headers that cannot have multiple values,
// while potentially having a comma in their single value.
var singleValueHeaders = ['user-agent'];
/**
 * Converts a given `Headers` instance into a plain object.
 * Respects headers with multiple values.
 */
function headersToObject(headers) {
    var headersObject = {};
    headers.forEach(function (value, name) {
        var isMultiValue = !singleValueHeaders.includes(name.toLowerCase()) && value.includes(',');
        headersObject[name] = isMultiValue
            ? value.split(',').map(function (s) { return s.trim(); })
            : value;
    });
    return headersObject;
}
exports.headersToObject = headersToObject;
});

var stringToHeaders_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Converts a string representation of headers (i.e. from XMLHttpRequest)
 * to a new `Headers` instance.
 */
function stringToHeaders(str) {
    var lines = str.trim().split(/[\r\n]+/);
    return lines.reduce(function (headers, line) {
        var parts = line.split(': ');
        var name = parts.shift();
        var value = parts.join(': ');
        headers.append(name, value);
        return headers;
    }, new Headers());
}
exports.stringToHeaders = stringToHeaders;
});

var listToHeaders_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
function listToHeaders(list) {
    var headers = new Headers();
    list.forEach(function (_a) {
        var name = _a[0], value = _a[1];
        var values = [].concat(value);
        values.forEach(function (value) {
            headers.append(name, value);
        });
    });
    return headers;
}
exports.listToHeaders = listToHeaders;
});

var reduceHeadersObject_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Reduces given headers object instnace.
 */
function reduceHeadersObject(headers, reducer, initialState) {
    return Object.keys(headers).reduce(function (nextHeaders, name) {
        return reducer(nextHeaders, name, headers[name]);
    }, initialState);
}
exports.reduceHeadersObject = reduceHeadersObject;
});

var objectToHeaders_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Converts a given headers object to a new `Headers` instance.
 */
function objectToHeaders(obj) {
    return reduceHeadersObject_1.reduceHeadersObject(obj, function (headers, name, value) {
        var values = [].concat(value);
        values.forEach(function (value) {
            headers.append(name, value);
        });
        return headers;
    }, new Headers());
}
exports.objectToHeaders = objectToHeaders;
});

var flattenHeadersList_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
function flattenHeadersList(list) {
    return list.map(function (_a) {
        var name = _a[0], values = _a[1];
        return [name, [].concat(values).join('; ')];
    });
}
exports.flattenHeadersList = flattenHeadersList;
});

var flattenHeadersObject_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

function flattenHeadersObject(obj) {
    return reduceHeadersObject_1.reduceHeadersObject(obj, function (headers, name, value) {
        headers[name] = [].concat(value).join('; ');
        return headers;
    }, {});
}
exports.flattenHeadersObject = flattenHeadersObject;
});

var lib = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

exports.Headers = Headers_1.Headers;

exports.headersToList = headersToList_1.headersToList;

exports.headersToObject = headersToObject_1.headersToObject;

exports.stringToHeaders = stringToHeaders_1.stringToHeaders;

exports.listToHeaders = listToHeaders_1.listToHeaders;

exports.objectToHeaders = objectToHeaders_1.objectToHeaders;

exports.reduceHeadersObject = reduceHeadersObject_1.reduceHeadersObject;

exports.flattenHeadersList = flattenHeadersList_1.flattenHeadersList;

exports.flattenHeadersObject = flattenHeadersObject_1.flattenHeadersObject;
});

var codes = {
	"100": "Continue",
	"101": "Switching Protocols",
	"102": "Processing",
	"103": "Early Hints",
	"200": "OK",
	"201": "Created",
	"202": "Accepted",
	"203": "Non-Authoritative Information",
	"204": "No Content",
	"205": "Reset Content",
	"206": "Partial Content",
	"207": "Multi-Status",
	"208": "Already Reported",
	"226": "IM Used",
	"300": "Multiple Choices",
	"301": "Moved Permanently",
	"302": "Found",
	"303": "See Other",
	"304": "Not Modified",
	"305": "Use Proxy",
	"307": "Temporary Redirect",
	"308": "Permanent Redirect",
	"400": "Bad Request",
	"401": "Unauthorized",
	"402": "Payment Required",
	"403": "Forbidden",
	"404": "Not Found",
	"405": "Method Not Allowed",
	"406": "Not Acceptable",
	"407": "Proxy Authentication Required",
	"408": "Request Timeout",
	"409": "Conflict",
	"410": "Gone",
	"411": "Length Required",
	"412": "Precondition Failed",
	"413": "Payload Too Large",
	"414": "URI Too Long",
	"415": "Unsupported Media Type",
	"416": "Range Not Satisfiable",
	"417": "Expectation Failed",
	"418": "I'm a Teapot",
	"421": "Misdirected Request",
	"422": "Unprocessable Entity",
	"423": "Locked",
	"424": "Failed Dependency",
	"425": "Too Early",
	"426": "Upgrade Required",
	"428": "Precondition Required",
	"429": "Too Many Requests",
	"431": "Request Header Fields Too Large",
	"451": "Unavailable For Legal Reasons",
	"500": "Internal Server Error",
	"501": "Not Implemented",
	"502": "Bad Gateway",
	"503": "Service Unavailable",
	"504": "Gateway Timeout",
	"505": "HTTP Version Not Supported",
	"506": "Variant Also Negotiates",
	"507": "Insufficient Storage",
	"508": "Loop Detected",
	"509": "Bandwidth Limit Exceeded",
	"510": "Not Extended",
	"511": "Network Authentication Required"
};

var statuses = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': codes
});

const status = (statusCode, statusText) => {
    return (res) => {
        res.status = statusCode;
        res.statusText =
            statusText || statuses[String(statusCode)];
        return res;
    };
};

function set(...args) {
    return (res) => {
        const [name, value] = args;
        if (typeof name === 'string') {
            res.headers.append(name, value);
        }
        else {
            const headers = lib.objectToHeaders(name);
            headers.forEach((value, name) => {
                res.headers.append(name, value);
            });
        }
        return res;
    };
}

/**
 * Returns a boolean indicating if the current process is running in NodeJS environment.
 */
// Please see https://github.com/mswjs/msw/pull/255
function isNodeProcess() {
    if (typeof global !== 'object') {
        // check browser environment
        return false;
    }
    if (Object.prototype.toString.call(global.process) === '[object process]' ||
        navigator.product === 'ReactNative') {
        // check nodejs or react native environment
        return true;
    }
}

const MIN_SERVER_RESPONSE_TIME = 100;
const MAX_SERVER_RESPONSE_TIME = 400;
const NODE_SERVER_RESPONSE_TIME = 5;
const getRandomServerResponseTime = () => {
    if (isNodeProcess()) {
        return NODE_SERVER_RESPONSE_TIME;
    }
    return Math.floor(Math.random() * (MAX_SERVER_RESPONSE_TIME - MIN_SERVER_RESPONSE_TIME) +
        MIN_SERVER_RESPONSE_TIME);
};
/**
 * Delays the current response for the given duration (in ms)
 * @example
 * res(delay()) // realistic server response time
 * res(delay(1500)) // explicit response delay duration
 */
const delay = (durationMs) => {
    return (res) => {
        res.delay = durationMs !== null && durationMs !== void 0 ? durationMs : getRandomServerResponseTime();
        return res;
    };
};

const useFetch = isNodeProcess() ? require('node-fetch') : window.fetch;
const gracefully = (promise) => {
    return promise.then((res) => {
        var _a;
        if ((_a = res.headers.get('content-type')) === null || _a === void 0 ? void 0 : _a.includes('json')) {
            return res.json();
        }
        return res.text();
    });
};
const augmentRequestInit = (requestInit) => {
    const headers = new lib.Headers(requestInit.headers);
    headers.set('x-msw-bypass', 'true');
    return Object.assign(Object.assign({}, requestInit), { headers: headers.getAllHeaders() });
};
/**
 * Wrapper around the native `window.fetch()` function that performs
 * a request bypassing MSW. Requests performed using
 * this function will never be mocked.
 */
const fetch = (input, requestInit = {}) => {
    // Keep the default `window.fetch()` call signature
    if (typeof input === 'string') {
        return gracefully(useFetch(input, augmentRequestInit(requestInit)));
    }
    const { body } = input;
    const compliantReq = augmentRequestInit(Object.assign(Object.assign({}, input), { body: typeof body === 'object' ? JSON.stringify(body) : body }));
    return gracefully(useFetch(input.url.href, compliantReq));
};

const defaultContext = {
    status,
    set,
    delay,
    fetch,
};

/**
 * Composes a given list of functions into a new function that
 * executes from right to left.
 */
function compose(...funcs) {
    return funcs.reduce((f, g) => (...args) => f(g(...args)));
}

class NetworkError extends Error {
    constructor(message) {
        super(message);
        this.name = 'NetworkError';
    }
}

const defaultResponse = {
    status: 200,
    statusText: 'OK',
    body: null,
    delay: 0,
    once: false,
};
function createResponseComposition(overrides = {}) {
    return (...transformers) => {
        const resolvedResponse = Object.assign({}, defaultResponse, {
            headers: new lib.Headers({
                'x-powered-by': 'msw',
            }),
        }, overrides);
        if (transformers.length > 0) {
            return compose(...transformers)(resolvedResponse);
        }
        return resolvedResponse;
    };
}
const response = Object.assign(createResponseComposition(), {
    once: createResponseComposition({ once: true }),
    networkError(message) {
        throw new NetworkError(message);
    },
});

/**
 * Returns a mocked response for a given request using following request handlers.
 */
const getResponse = (req, handlers) => __awaiter(void 0, void 0, void 0, function* () {
    const relevantHandlers = handlers
        .filter((requestHandler) => {
        // Skip a handler if it has been already used for a one-time response.
        return !requestHandler.shouldSkip;
    })
        .map((requestHandler) => {
        // Parse the captured request to get additional information.
        // Make the predicate function accept all the necessary information
        // to decide on the interception.
        const parsedRequest = requestHandler.parse
            ? requestHandler.parse(req)
            : null;
        return [requestHandler, parsedRequest];
    })
        .filter(([requestHandler, parsedRequest]) => {
        return requestHandler.predicate(req, parsedRequest);
    });
    if (relevantHandlers.length == 0) {
        // Handle a scenario when a request has no relevant request handlers.
        // In that case it would be bypassed (performed as-is).
        return {
            handler: null,
            response: null,
        };
    }
    const { requestHandler, parsedRequest, mockedResponse, publicRequest, } = yield relevantHandlers.reduce((asyncAcc, [requestHandler, parsedRequest]) => __awaiter(void 0, void 0, void 0, function* () {
        // Now the reduce function is async so we need to await if response was found
        const acc = yield asyncAcc;
        // If a first not empty response was found we'll stop evaluating other requests
        if (acc.requestHandler) {
            return acc;
        }
        const { getPublicRequest, defineContext, resolver } = requestHandler;
        const publicRequest = getPublicRequest
            ? getPublicRequest(req, parsedRequest)
            : req;
        const context = defineContext
            ? defineContext(publicRequest)
            : defaultContext;
        const mockedResponse = yield resolver(publicRequest, response, context);
        if (!mockedResponse) {
            return acc;
        }
        if (mockedResponse && mockedResponse.once) {
            // When responded with a one-time response, match the relevant request handler
            // as skipped, so it cannot affect the captured requests anymore.
            requestHandler.shouldSkip = true;
        }
        return {
            requestHandler,
            parsedRequest,
            mockedResponse,
            publicRequest,
        };
    }), Promise.resolve({ mockedResponse: null }));
    // Although reducing a list of relevant request handlers, it's possible
    // that in the end there will be no handler associted with the request
    // (i.e. if relevant handlers are fall-through).
    if (!requestHandler) {
        return {
            handler: null,
            response: null,
        };
    }
    return {
        handler: requestHandler,
        response: mockedResponse,
        publicRequest,
        parsedRequest,
    };
});

/**
 * Parses a given string into a JSON.
 * Does not throw an exception on an invalid JSON string.
 */
function jsonParse(str) {
    try {
        return JSON.parse(str);
    }
    catch (error) {
        return undefined;
    }
}

/**
 * Returns a parsed JSON from a given valid body string,
 * otherwise returns a given body string as-is.
 */
function getJsonBody(body) {
    return jsonParse(body) || body;
}

function parseRequestBody(body, headers) {
    var _a;
    if (body) {
        // If the intercepted request's body has a JSON Content-Type
        // parse it into an object, otherwise leave as-is.
        const hasJsonContent = (_a = headers === null || headers === void 0 ? void 0 : headers.get('content-type')) === null || _a === void 0 ? void 0 : _a.includes('json');
        if (hasJsonContent && typeof body !== 'object') {
            return getJsonBody(body);
        }
        return body;
    }
    // Return whatever falsey body value is given.
    return body;
}

function use(currentHandlers, ...handlers) {
    currentHandlers.unshift(...handlers);
}
function restoreHandlers(handlers) {
    handlers.forEach((handler) => {
        if ('shouldSkip' in handler) {
            handler.shouldSkip = false;
        }
    });
}
function resetHandlers(initialHandlers, ...nextHandlers) {
    return nextHandlers.length > 0 ? [...nextHandlers] : [...initialHandlers];
}

function onUnhandledRequest(request, onUnhandledRequest = 'bypass') {
    if (typeof onUnhandledRequest === 'function') {
        onUnhandledRequest(request);
        return;
    }
    const message = `captured a ${request.method} ${request.url} request without a corresponding request handler.`;
    switch (onUnhandledRequest) {
        case 'error': {
            throw new Error(`[MSW] Error: ${message}`);
        }
        case 'warn': {
            console.warn(`[MSW] Warning: ${message}`);
        }
        default:
            return;
    }
}

const DEFAULT_LISTEN_OPTIONS = {
    onUnhandledRequest: 'bypass',
};
/**
 * Sets up a server-side requests interception with the given mock definition.
 */
const setupServer = (...requestHandlers) => {
    const interceptor = new nodeRequestInterceptor.RequestInterceptor();
    // Error when attempting to run this function in a browser environment.
    if (!isNodeProcess()) {
        throw new Error('[MSW] Failed to execute `setupServer` in the environment that is not NodeJS (i.e. a browser). Consider using `setupWorker` instead.');
    }
    // Store the list of request handlers for the current server instance,
    // so it could be modified at a runtime.
    let currentHandlers = [...requestHandlers];
    return {
        /**
         * Enables requests interception based on the previously provided mock definition.
         */
        listen(options) {
            const resolvedOptions = Object.assign({}, DEFAULT_LISTEN_OPTIONS, options);
            interceptor.use((req) => __awaiter(this, void 0, void 0, function* () {
                const requestHeaders = new lib.Headers(lib.flattenHeadersObject(req.headers || {}));
                const requestCookieString = requestHeaders.get('cookie');
                const mockedRequest = {
                    url: req.url,
                    method: req.method,
                    // Parse the request's body based on the "Content-Type" header.
                    body: parseRequestBody(req.body, requestHeaders),
                    headers: requestHeaders,
                    cookies: {},
                    params: {},
                    redirect: 'manual',
                    referrer: '',
                    keepalive: false,
                    cache: 'default',
                    mode: 'cors',
                    referrerPolicy: 'no-referrer',
                    integrity: '',
                    destination: 'document',
                    bodyUsed: false,
                    credentials: 'same-origin',
                };
                if (requestCookieString) {
                    // Set mocked request cookies from the `cookie` header of the original request.
                    // No need to take `credentials` into account, because in NodeJS requests are intercepted
                    // _after_ they happen. Request issuer should have already taken care of sending relevant cookies.
                    // Unlike browser, where interception is on the worker level, _before_ the request happens.
                    mockedRequest.cookies = parse_1(requestCookieString);
                }
                if (mockedRequest.headers.get('x-msw-bypass')) {
                    return;
                }
                const { response } = yield getResponse(mockedRequest, currentHandlers);
                if (!response) {
                    onUnhandledRequest(mockedRequest, resolvedOptions.onUnhandledRequest);
                    return;
                }
                return new Promise((resolve) => {
                    var _a;
                    // the node build will use the timers module to ensure @sinon/fake-timers or jest fake timers
                    // don't affect this timeout.
                    setTimeout(() => {
                        resolve({
                            status: response.status,
                            statusText: response.statusText,
                            headers: response.headers.getAllHeaders(),
                            body: response.body,
                        });
                    }, (_a = response.delay) !== null && _a !== void 0 ? _a : 0);
                });
            }));
        },
        /**
         * Prepends given request handlers to the list of existing handlers.
         */
        use(...handlers) {
            use(currentHandlers, ...handlers);
        },
        /**
         * Marks all request handlers that respond using `res.once()` as unused.
         */
        restoreHandlers() {
            restoreHandlers(currentHandlers);
        },
        /**
         * Resets request handlers to the initial list given to the `setupServer` call, or to the explicit next request handlers list, if given.
         */
        resetHandlers(...nextHandlers) {
            currentHandlers = resetHandlers(requestHandlers, ...nextHandlers);
        },
        /**
         * Stops requests interception by restoring all augmented modules.
         */
        close() {
            interceptor.restore();
        },
    };
};

exports.setupServer = setupServer;
